PhexTask{#order:2,#uuid:UUID['a3938ff5a99f0d008d13f1720a299503'],#title:'Tutorial',#description:'\r# Tutorial\r## Context: the OCDBox objects loop\rIn this example, we will use a class named `OCDBox`. It models a trivial object named box that holds objects. It has two instance variables, elements and name, and a few methods in its API. In particular, the method `OCDBox>>#addElement:`  (click on it) adds an object into the box.\r\rWe will use a test to practice object-centric breakpoints. In this test, we instantiate 100 boxes. We iterate over all these boxes to:\r\r* add an object to each box,\r *  print the box on the Transcript.\r\rOpen the transcript (Browse > Transcript) then execute this test: `OCDBoxTest>>#testMultipleBoxes`.\rThe transcript shows you each box that is printed in the iteration loop. \rIf you look at the code of the OCDBox class, you will see that:\r\r* adding an element (`OCDBox>>#addElement:` )  to a box modifies its name,\r *  the printing method (`OCDBox>>#printString` ) uses the name to display the box in the Transcript.\r\r## Tutorial: Breaking when an object receives a message \r\r### Use-cases\r\rThe typical use-case for this object-centric breakpoint is when you have many instances of the same class running in your program, while you are interested to debug a method for one specific object among these instances. You are interested to answer the following question: _When is this particular object executing this particular method during the execution?_ \r\r### Exercise 1\r\rThe `OCDBoxTest>>#testMultipleBoxes` test iterates over a hundred boxes objects, and to each object it sends the  `#addElement:` message. In this exercise, we select one box object among all the iterated boxes, and we install an object-centric breakpoint on the `OCDBox>>#addElement:` method of that object. Then, we proceed the test and the  the  `#addElement:` message is sent to each of the boxes. The execution only stops when the selected box executes the `OCDBox>>#addElement:` method.\r\r**Step 1: getting to the object to debug**\rLet us say that we want to debug the tenth box in the box collection.\rThe first step of object-centric debugging is to obtain this box object.\rTo do that, we first have to interrupt our execution and find the object in the debugger:\r* Go to `OCDBoxTest>>#testMultipleBoxes` (click on it)\r* Add a `self halt.` instruction just after the first `100 timesRepeat` loop\r* Execute the test: the debugger opens on your halt\r* Select the `Boxes` variable into the bottom inspector\r* Select the object at index 10: you got the object to debug!\r\r**Step 2: installing an object-centric breakpoint on our object**\rIn the meta inspection pane of the object you just selected, find the method  `OCDBox>>#addElement:`.\r* Right-click on that method, and select _halt on call_ in the menu\r* Proceed the execution in the debugger\r\rThe test continues and  iterates over the hundred boxes, and sends the addElement: message to each box object.\rOnly the box number 10 that you instrumented breaks when executing this method!\r\r## Tutorial: Breaking when the state of a specific object is touched\r\r### Use-cases\r\rThe typical use-case for this object-centric breakpoint is when you have many instances of the same class running in your program, while you are interested to know when the state of one specific object is modified. You are interested to answer the following question: _When is the state of this particular object modified during the execution?_\r\r### Exercise 2\r\rIn this exercise, we reuse our test iterating over a hundred box objects. We select again a box among all the iterated boxes, but this time we want to stop when the `name` instance variable of that box is written to. To that end, we install an object-centric breakpoint on all write accesses to that variable in the selected object. Then, we proceed the test and the execution only breaks when the name instance variable of the selected box is modified.\r\r**Step 1: getting to the object to debug**\rPerform again the instructions from **Step 1** of **Exercise 1**.\r\r**Step 1: getting to the object to debug**\rIn the raw pane of the inspector opened on your box object:\r* Select the name instance variable in the table\r* Right-click on that  item, and select `halt on write` in the menu\r* Proceed the execution in the debugger\r\rThe test continues and iterates over the hundred boxes.\rThe execution breaks only when the box object we instrumented writes into its `name` instance variable. All other objects are not affected by the breakpoint.\r\r## Removing and disabling breakpoints \rBreakpoints can be definitely removed, or temporary disabled.\r\r**From the breakpoint navigator**\rThe breakpoint navigator gives us views and control over breakpoints installed in the system, such as visualizing where breakpoints are located in the source code and disabling/enabling them dynamically.\r\rThe navigator is accessible through Pharo main menu:\r\r![breakpoint-nav](https://github.com/StevenCostiou/Pharo-VariableBreakpoint-Tutorial/raw/main/pictures/breakpoint-bnav-menu.png)\r\rIn this navigator, you see the following elements: \r1. The list of installed breakpoints in the system \r2. The list of methods affected by the selected breakpoint\r3. The source code of the selected affected method, with the breakpoint locations highlighted\r\rTo enable or disable a breakpoint, just tick and untick the checkbox of the breakpoint.\rDisabling a breakpoint does not uninstall it, but it stops having any effect.\rDisabling and enabling breakpoints can be done dynamically at any point when your program is running.\r\rTo remove a breakpoint, just right click on the breakpoint line and select _remove_.\r\rWhen you select a breakpoint, you see the list of methods affected by that breakpoint.\rWhen you select one of these methods, you see the source code of that method with, highlighted, all the locations in the source code where (or when!) the breakpoint will interrupt the execution.\r\r![breakpoint-nav-menu](https://github.com/StevenCostiou/Pharo-VariableBreakpoint-Tutorial/raw/main/pictures/breakpoint-navigator.png)\r\r**From the inspector**\rRemoving a breakpoint from the inspector is straightforward.\rJust inspect the object on which you installed a breakpoint. \rGo into the breakpoint pane: you can control breakpoints from there in the same manner as in the breakpoint navigator.\r\r### Exercise 3\rDo again exercise 1 and 2, but this time experiment breakpoint enabling/disabling and uninstalling through the breakpoint navigator and through the breakpoint pane when you inspect objects.\r\r',#contents:'\r# Tutorial\r## Context: the OCDBox objects loop\rIn this example, we will use a class named `OCDBox`. It models a trivial object named box that holds objects. It has two instance variables, elements and name, and a few methods in its API. In particular, the method `OCDBox>>#addElement:`  (click on it) adds an object into the box.\r\rWe will use a test to practice object-centric breakpoints. In this test, we instantiate 100 boxes. We iterate over all these boxes to:\r\r* add an object to each box,\r *  print the box on the Transcript.\r\rOpen the transcript (Browse > Transcript) then execute this test: `OCDBoxTest>>#testMultipleBoxes`.\rThe transcript shows you each box that is printed in the iteration loop. \rIf you look at the code of the OCDBox class, you will see that:\r\r* adding an element (`OCDBox>>#addElement:` )  to a box modifies its name,\r *  the printing method (`OCDBox>>#printString` ) uses the name to display the box in the Transcript.\r\r## Tutorial: Breaking when an object receives a message \r\r### Use-cases\r\rThe typical use-case for this object-centric breakpoint is when you have many instances of the same class running in your program, while you are interested to debug a method for one specific object among these instances. You are interested to answer the following question: _When is this particular object executing this particular method during the execution?_ \r\r### Exercise 1\r\rThe `OCDBoxTest>>#testMultipleBoxes` test iterates over a hundred boxes objects, and to each object it sends the  `#addElement:` message. In this exercise, we select one box object among all the iterated boxes, and we install an object-centric breakpoint on the `OCDBox>>#addElement:` method of that object. Then, we proceed the test and the  the  `#addElement:` message is sent to each of the boxes. The execution only stops when the selected box executes the `OCDBox>>#addElement:` method.\r\r**Step 1: getting to the object to debug**\rLet us say that we want to debug the tenth box in the box collection.\rThe first step of object-centric debugging is to obtain this box object.\rTo do that, we first have to interrupt our execution and find the object in the debugger:\r* Go to `OCDBoxTest>>#testMultipleBoxes` (click on it)\r* Add a `self halt.` instruction just after the first `100 timesRepeat` loop\r* Execute the test: the debugger opens on your halt\r* Select the `Boxes` variable into the bottom inspector\r* Select the object at index 10: you got the object to debug!\r\r**Step 2: installing an object-centric breakpoint on our object**\rIn the meta inspection pane of the object you just selected, find the method  `OCDBox>>#addElement:`.\r* Right-click on that method, and select _halt on call_ in the menu\r* Proceed the execution in the debugger\r\rThe test continues and  iterates over the hundred boxes, and sends the addElement: message to each box object.\rOnly the box number 10 that you instrumented breaks when executing this method!\r\r## Tutorial: Breaking when the state of a specific object is touched\r\r### Use-cases\r\rThe typical use-case for this object-centric breakpoint is when you have many instances of the same class running in your program, while you are interested to know when the state of one specific object is modified. You are interested to answer the following question: _When is the state of this particular object modified during the execution?_\r\r### Exercise 2\r\rIn this exercise, we reuse our test iterating over a hundred box objects. We select again a box among all the iterated boxes, but this time we want to stop when the `name` instance variable of that box is written to. To that end, we install an object-centric breakpoint on all write accesses to that variable in the selected object. Then, we proceed the test and the execution only breaks when the name instance variable of the selected box is modified.\r\r**Step 1: getting to the object to debug**\rPerform again the instructions from **Step 1** of **Exercise 1**.\r\r**Step 1: getting to the object to debug**\rIn the raw pane of the inspector opened on your box object:\r* Select the name instance variable in the table\r* Right-click on that  item, and select `halt on write` in the menu\r* Proceed the execution in the debugger\r\rThe test continues and iterates over the hundred boxes.\rThe execution breaks only when the box object we instrumented writes into its `name` instance variable. All other objects are not affected by the breakpoint.\r\r## Removing and disabling breakpoints \rBreakpoints can be definitely removed, or temporary disabled.\r\r**From the breakpoint navigator**\rThe breakpoint navigator gives us views and control over breakpoints installed in the system, such as visualizing where breakpoints are located in the source code and disabling/enabling them dynamically.\r\rThe navigator is accessible through Pharo main menu:\r\r![breakpoint-nav](https://github.com/StevenCostiou/Pharo-VariableBreakpoint-Tutorial/raw/main/pictures/breakpoint-bnav-menu.png)\r\rIn this navigator, you see the following elements: \r1. The list of installed breakpoints in the system \r2. The list of methods affected by the selected breakpoint\r3. The source code of the selected affected method, with the breakpoint locations highlighted\r\rTo enable or disable a breakpoint, just tick and untick the checkbox of the breakpoint.\rDisabling a breakpoint does not uninstall it, but it stops having any effect.\rDisabling and enabling breakpoints can be done dynamically at any point when your program is running.\r\rTo remove a breakpoint, just right click on the breakpoint line and select _remove_.\r\rWhen you select a breakpoint, you see the list of methods affected by that breakpoint.\rWhen you select one of these methods, you see the source code of that method with, highlighted, all the locations in the source code where (or when!) the breakpoint will interrupt the execution.\r\r![breakpoint-nav-menu](https://github.com/StevenCostiou/Pharo-VariableBreakpoint-Tutorial/raw/main/pictures/breakpoint-navigator.png)\r\r**From the inspector**\rRemoving a breakpoint from the inspector is straightforward.\rJust inspect the object on which you installed a breakpoint. \rGo into the breakpoint pane: you can control breakpoints from there in the same manner as in the breakpoint navigator.\r\r### Exercise 3\rDo again exercise 1 and 2, but this time experiment breakpoint enabling/disabling and uninstalling through the breakpoint navigator and through the breakpoint pane when you inspect objects.\r\r',#started:false,#finished:false,#requiresAnswer:false,#requiredAnswer:'You have no answer to provide'}