PhexTask{#order:2,#uuid:UUID['9f23571e59b40d00ae5ed0cb076258d9'],#title:'Tutorial',#description:'# Tutorial\r\rThis tutorial contains 2 guided exercises.\rEstimated time: 10 minutes.\rDifficulty: easy.\r\r## Context: the OCDBox objects loop\rIn this example, we will use a class named `OCDBox`. It models a box that holds objects. It has two instance variables, `elements` and `name`, and a few methods in its API. In particular, the method `OCDBox>>#addElement:` (click on it) adds an object into a box.\r\rWe will use a test to practice object-centric breakpoints. In this test, we instantiate 100 boxes. We iterate over all these boxes to:\r\r* Add an object to each box,\r* print the box on the Transcript.\r\rOpen the transcript (Browse > Transcript) then execute this test: `OCDBoxTest>>#testMultipleBoxes`.\rThe transcript shows you each box that is printed in the iteration loop. \rIf you look at the code of the OCDBox class, you will see that:\r\r* Adding an element (`OCDBox>>#addElement:`)  to a box modifies its name,\r* the printing method (`OCDBox>>#printString`) uses the name of a box to display that box in the Transcript.\r\r## Tutorial: Breaking when an object receives a message (`haltOnCall`) \r\r### Scenario\r\rThe typical scenario for `haltOnCall` is when you have many instances of the same class running in your program, and you want to debug a specific method for one specific instance. You are interested to answer the following question: _When is this particular object executing this particular method?_ \r\r### Exercise 1\r\rThe `OCDBoxTest>>#testMultipleBoxes` test iterates over 100 box objects, and to each box it sends the  `#addElement:` message. In this exercise, we select one box among all the iterated boxes, and we install a `haltOnCall` breakpoint on the `OCDBox>>#addElement:` method of that box. Then, we proceed the test and the  `#addElement:` message is sent to each of the boxes. The execution breaks only when the selected box executes the `OCDBox>>#addElement:` method.\r\r**Step 1: get to the box to debug**\rLet us say that we want to debug the tenth box in the box collection.\rThe first step of object-centric debugging is to obtain this box.\r\rTo do that, we first have to interrupt our execution and find the object in the debugger:\r* Go to `OCDBoxTest>>#testMultipleBoxes` (click on it)\r* Add a `self halt.` instruction just after the first `100 timesRepeat` loop\r* Execute the test: the debugger opens on your halt\r* Select the `Boxes` variable into the bottom inspector\r* Select the 10th box: you got the object to debug!\r\r**Step 2: install a `haltOnCall` breakpoint on our box**\rIn the object inspector, go to the meta inspection pane and find the method  `OCDBox>>#addElement:`.\r* Right-click on that method, and select _halt on call_ in the menu,\r* proceed the execution in the debugger.\r\rThe test continues and  iterates over the hundred boxes, and sends the addElement: message to each box object. Only the box number 10 that you instrumented breaks when executing this method!\r\r## Tutorial: Breaking when the state of a specific object is touched\r\r### Scenario\r\rThe typical scenario for this breakpoint is when you have many instances of the same class running in your program, while you are interested to know when the state of one specific object is modified. You are interested to answer the following question: _When and how is the state of this particular object modified?_\r\r### Exercise 2\r\rIn this exercise, we reuse our test iterating over a hundred box objects. We select again a box among all the iterated boxes, but this time we want to stop when the `name` instance variable of that box is written to. To that end, we install an object-centric breakpoint on all write accesses to that variable in the selected object. Then, we proceed the test and the execution only breaks when the name instance variable of the selected box is modified.\r\r**Step 1: get to the box to debug**\rPerform again the instructions from **Step 1** of **Exercise 1**.\r\r**Step 2: install the breakpoint on the `name` variable**\rIn the raw pane of the inspector opened on your box object:\r* Select the `name` instance variable in the table,\r* right-click on that  item, and select `halt on write` in the menu,\r* proceed the execution in the debugger.\r\rThe test continues and iterates over the hundred boxes.The execution breaks only when the box object we instrumented writes into its `name` instance variable. All other objects are not affected by the breakpoint.\r\r## Removing and disabling breakpoints \rBreakpoints can be removed or disabled.\r\r**From the breakpoint navigator**\rThe breakpoint navigator gives us views and control over breakpoints installed in the system, such as visualizing where breakpoints are located in the source code and disabling/enabling them dynamically.\r\rThe navigator is accessible through Pharo main menu:\r\r![breakpoint-nav](https://github.com/StevenCostiou/Pharo-VariableBreakpoint-Tutorial/raw/main/pictures/breakpoint-bnav-menu.png)\r\rIn this navigator (see screenshot below), you see the following elements: \r1. The list of installed breakpoints in the system, \r2. the list of methods affected by the selected breakpoint,\r3. the source code of the selected affected method, with the breakpoint locations highlighted.\r\r![breakpoint-nav-menu](https://github.com/StevenCostiou/Pharo-VariableBreakpoint-Tutorial/raw/main/pictures/breakpoint-navigator.png)\r\rTo enable or disable a breakpoint, just tick and untick the checkbox of the breakpoint.\rDisabling a breakpoint does not uninstall it, but it stops having any effect.\rDisabling and enabling breakpoints can be done dynamically at any point when your program is running.\r\rTo remove a breakpoint, just right click on the breakpoint line and select _remove_.\r\rWhen you select a breakpoint, you see the list of methods affected by that breakpoint.\rWhen you select one of these methods, you see the source code of that method with, highlighted, all the locations in the source code where or when the breakpoint will interrupt the execution.\r\r**From the inspector**\rRemoving a breakpoint from the inspector is straightforward. Just inspect the object on which you installed a breakpoint.  Go into the breakpoint pane: you can control breakpoints from there in the same manner as in the breakpoint navigator.',#contents:'# Tutorial\r\rThis tutorial contains 2 guided exercises.\rEstimated time: 10 minutes.\rDifficulty: easy.\r\r## Context: the OCDBox objects loop\rIn this example, we will use a class named `OCDBox`. It models a box that holds objects. It has two instance variables, `elements` and `name`, and a few methods in its API. In particular, the method `OCDBox>>#addElement:` (click on it) adds an object into a box.\r\rWe will use a test to practice object-centric breakpoints. In this test, we instantiate 100 boxes. We iterate over all these boxes to:\r\r* Add an object to each box,\r* print the box on the Transcript.\r\rOpen the transcript (Browse > Transcript) then execute this test: `OCDBoxTest>>#testMultipleBoxes`.\rThe transcript shows you each box that is printed in the iteration loop. \rIf you look at the code of the OCDBox class, you will see that:\r\r* Adding an element (`OCDBox>>#addElement:`)  to a box modifies its name,\r* the printing method (`OCDBox>>#printString`) uses the name of a box to display that box in the Transcript.\r\r## Tutorial: Breaking when an object receives a message (`haltOnCall`) \r\r### Scenario\r\rThe typical scenario for `haltOnCall` is when you have many instances of the same class running in your program, and you want to debug a specific method for one specific instance. You are interested to answer the following question: _When is this particular object executing this particular method?_ \r\r### Exercise 1\r\rThe `OCDBoxTest>>#testMultipleBoxes` test iterates over 100 box objects, and to each box it sends the  `#addElement:` message. In this exercise, we select one box among all the iterated boxes, and we install a `haltOnCall` breakpoint on the `OCDBox>>#addElement:` method of that box. Then, we proceed the test and the  `#addElement:` message is sent to each of the boxes. The execution breaks only when the selected box executes the `OCDBox>>#addElement:` method.\r\r**Step 1: get to the box to debug**\rLet us say that we want to debug the tenth box in the box collection.\rThe first step of object-centric debugging is to obtain this box.\r\rTo do that, we first have to interrupt our execution and find the object in the debugger:\r* Go to `OCDBoxTest>>#testMultipleBoxes` (click on it)\r* Add a `self halt.` instruction just after the first `100 timesRepeat` loop\r* Execute the test: the debugger opens on your halt\r* Select the `Boxes` variable into the bottom inspector\r* Select the 10th box: you got the object to debug!\r\r**Step 2: install a `haltOnCall` breakpoint on our box**\rIn the object inspector, go to the meta inspection pane and find the method  `OCDBox>>#addElement:`.\r* Right-click on that method, and select _halt on call_ in the menu,\r* proceed the execution in the debugger.\r\rThe test continues and  iterates over the hundred boxes, and sends the addElement: message to each box object. Only the box number 10 that you instrumented breaks when executing this method!\r\r## Tutorial: Breaking when the state of a specific object is touched\r\r### Scenario\r\rThe typical scenario for this breakpoint is when you have many instances of the same class running in your program, while you are interested to know when the state of one specific object is modified. You are interested to answer the following question: _When and how is the state of this particular object modified?_\r\r### Exercise 2\r\rIn this exercise, we reuse our test iterating over a hundred box objects. We select again a box among all the iterated boxes, but this time we want to stop when the `name` instance variable of that box is written to. To that end, we install an object-centric breakpoint on all write accesses to that variable in the selected object. Then, we proceed the test and the execution only breaks when the name instance variable of the selected box is modified.\r\r**Step 1: get to the box to debug**\rPerform again the instructions from **Step 1** of **Exercise 1**.\r\r**Step 2: install the breakpoint on the `name` variable**\rIn the raw pane of the inspector opened on your box object:\r* Select the `name` instance variable in the table,\r* right-click on that  item, and select `halt on write` in the menu,\r* proceed the execution in the debugger.\r\rThe test continues and iterates over the hundred boxes.The execution breaks only when the box object we instrumented writes into its `name` instance variable. All other objects are not affected by the breakpoint.\r\r## Removing and disabling breakpoints \rBreakpoints can be removed or disabled.\r\r**From the breakpoint navigator**\rThe breakpoint navigator gives us views and control over breakpoints installed in the system, such as visualizing where breakpoints are located in the source code and disabling/enabling them dynamically.\r\rThe navigator is accessible through Pharo main menu:\r\r![breakpoint-nav](https://github.com/StevenCostiou/Pharo-VariableBreakpoint-Tutorial/raw/main/pictures/breakpoint-bnav-menu.png)\r\rIn this navigator (see screenshot below), you see the following elements: \r1. The list of installed breakpoints in the system, \r2. the list of methods affected by the selected breakpoint,\r3. the source code of the selected affected method, with the breakpoint locations highlighted.\r\r![breakpoint-nav-menu](https://github.com/StevenCostiou/Pharo-VariableBreakpoint-Tutorial/raw/main/pictures/breakpoint-navigator.png)\r\rTo enable or disable a breakpoint, just tick and untick the checkbox of the breakpoint.\rDisabling a breakpoint does not uninstall it, but it stops having any effect.\rDisabling and enabling breakpoints can be done dynamically at any point when your program is running.\r\rTo remove a breakpoint, just right click on the breakpoint line and select _remove_.\r\rWhen you select a breakpoint, you see the list of methods affected by that breakpoint.\rWhen you select one of these methods, you see the source code of that method with, highlighted, all the locations in the source code where or when the breakpoint will interrupt the execution.\r\r**From the inspector**\rRemoving a breakpoint from the inspector is straightforward. Just inspect the object on which you installed a breakpoint.  Go into the breakpoint pane: you can control breakpoints from there in the same manner as in the breakpoint navigator.',#started:false,#finished:false,#requiresAnswer:false,#requiredAnswer:'No answer to provide: click "ok" to continue'}